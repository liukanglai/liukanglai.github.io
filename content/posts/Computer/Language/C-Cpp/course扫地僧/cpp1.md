# day01

## c++ 基础

### 对 C 拓展

- 头文件
- using namespace std; 命名空间 cout << "jj"; (<< 运算符重载)
- register
- bool
- c 表达式返回的是一个值 c++表达式返回的是一个变量`(*(a<b? &a:&b) = 30)`

- const: `const int *a; int * const a; const int * const a;`
- 但 c 中的 const 还可更加指针修改，并不是真正的常量，cpp 才是，把常量放入符号表里面，不会变，取地址的话会另外为 a 赋空间。
- const 有作用域，#define 无

- 引用(Type& name = var;) 由来：int a = 1; 就可以用 a 操作其地址，那可不可以给这个地址空间取另外的名字 b 吗？
- 和指针一样占 4 个字节，给内存取别名
- 应用：做函数形参，不用传地址！
- 引用做函数返回值，接的是什么就给什么，可以是值，可以是指针
- 引用做左值，函数返回值是一个引用，那么函数中要用 static 变量
- 指针引用： int \* &p1 = p;

- 常引用：int x = 30; const int &y = x; y 是 x 的只读属性，不能通过 y 修改 x; (const int &y = 30;)
- 作用：传参，不用形参分配内存，且起只读作用

- inline 内联函数，替代 c 语言中：#define FUN(a,b)((a) < (b) ? (a) : (b))
- 直接在主函数中放入 inline 函数片段运行
- 和 #define 宏的区别：宏只是机械的进行变量替换，而内联函数同普通函数

- 函数的默认参数
- 函数的占位参数
- 占位参数也可加默认值

- new/delete

### 面向对象

- 面向对象是类的运行，面向过程：函数的运行

- 对象的生命周期，类之间的关系？
- 成员变量，成员函数，运行顺序？

- 重载：
- 函数的名一样，但参数的个数或类型或顺序不一样。注：只是放回值不一样不是重载
- 函数指针！typedef void (\*fun)(int a);

#### 类和对象

- 构造函数：类名
- 只要自己定义了构造函数，就没有默认的了
- 调用方法：Class A(1); Class A; VS Class A(); Class A = 1; Class A = (1, 2);
- 析构函数： ~类名

- Class A = Class(1,2);(匿名对象) Class A = B; VS A=B;
- 当函数返回一个对象时，会调用 copy 构造函数创建一个匿名对象，如果使用函数的返回值初始化一个对象，则将此匿名对象转正，若无，则无用析构掉
- 默认的 copy 构造函数是浅 copy，类里面的指针变量只是简单复制一下。要使用，自己写深 copy 构造函数

- 构造函数的初始化列表：需要初始化的变量！A(int a): b(1), c(2); 那构造函数的运行顺序（先 b 后 a），析构函数的运行顺序相反。

- 静态成员：static 属于这个类的所有对象，静态成员函数只能访问静态成员变量，普通变量它不知道是谁的

- 函数后面加一个 const，表示修饰的是 This 指针！

#### 封装

- 属性和方法的封装和权限
- public private protected，默认是私有的

- c++如何构建面向对象模型：

  1. 如何管理类中的代码：成员变量和成员函数分开存储，变量在对象中，static 在全局区，成员对象和函数都包含一个指向对象的指针（在代码区），static 无，任是内存四区模型！
  1. 对象之间的关系
  1.

1. 友元

- 访问类的 private
- friend

1. 运算符重载

- 自定义数据类型的运算符操作，ps：复数相加
- operator+ 函数调用 是全局函数，成员函数（权限问题需要友元函数）
- 前置++和后置++只有返回值不同，如何区分？占位符！
- \>> 的重载只能用全局函数，返回值用 osream&

#### 继承

- 访问控制：父类的 public private protected 权限继承用 public private protected 权限变化，(三看原则)
- 赋值兼容性原则：基类指针可以指向子类对象（用子类对象的地址给父类赋值）；
- 继承中的构造和析构顺序
- child.father:: b = 10;
- 多重继承二义性：
- virtual 虚继承
- 有些二义性无法解决

#### 多态

- 父类用子类的函数！框架已搭好
- 一套函数可以反复用，只要传进来的子类不同！是面向对象 3 大概念的核心
- 加 virtual ！子类可不加，实现多态
- 虚析构函数：通过父类指针，调用子类对象的析构函数，释放所有资源（直接通过子类对象删时也可）
- 重载（同一个类中）和重写（父类和子类函数一模一样，加 virtual 是多态，不加是重定义）；子类无法重载父类的函数，同名会覆盖！

- 三个条件：继承，virtual 重写，父类指针（引用）指向子类对象

- 实现多态的原理：vptr 指针，虚函数表
- vptr 指针的分步初始化：先完成父类的构造函数，vptr 指向父类的虚函数表，然后指向子类的

#### 纯虚函数和抽象类

- virtual int get() = 0;
- 多接口继承没有普通的多继承的二义性问题

- 面向抽象类编程（接口）

> 重要的思想：继承和组合，注入，控制反转 IOC，MVC(model, view, control)，面向对象思想拓展 aop 思想(横向编程)

#### C 面向接口编程和 C 多态

- 函数指针 `int (*fun)(int a, int b)`
- 进阶用法，函数指针做函数参数 (虚函数表，多态)
- 回调函数: 定义一个函数指针类型（typedef）约定任务函数的规范，以后编写者写好，使用者调用即可

> p280 观看

1. 异常

- try catch
- 栈解旋：throw 后，类析构
- throw 的变量的生命周期是啥，如果使用一个元素来接异常，会 copy 构造函数；如果是引用，会使用那个 throw 时的对象
- Exception

> 类型转换

- static_cast: 静态类型转换，int->char... 编译时做类型检查，对于 c 中的隐式类型转换
- reinterpret_cast: 重新解释转换，不同类型的强制类型转换
- dynamic_cast: 动态类型转换，子类和父类之间的多态类型转换
- const_cast: 把只读变为可改
- Type B = static_cast\<Type>(A);

1. OI

- iostream
- cout/cin
- cin.get()
- cin.getline(buf, 256)
- cin.ingore()
- cin.peek()
- cin.putback()

- cout

- 文件

## 提高

### 函数模版和类模版

> 就是泛型编程

- 函数的参数类型不一样，但实现的功能一样，如何只定义一个函数处理
- 重载：普通函数可以隐式转换数据类型，函数模板不会，严格验证类型；都匹配时，优先使用普通函数(加<>使用模板)；模板更好匹配，则调用函数模板
- c++ 编译器会根据函数的调用来生成不同的函数，有几个不同的形参生成几个；两次编译，声明，调用

```cpp
// 开始泛型编程
template<typename T, typename T1>
void swap(T &a, T1 &b){
    T c;
    c = a;
    a = b;
    b = c;
}
swap<int,int>(x,y);
```

- 类模板
- 类中的数据不受具体数据类型的影响
- Linux 内核链表
- 子类派生时，需要具体指定父类的模板类型，才能分配大小；也可以从模板类派生模板类。
- 类模板的 static，几个类型有几个 static

### stl


#### 容器

1. vector

    - 

1. string


1. stack

1. queue

#### 算法

#### 迭代器

### 设计模式

### boost
