<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>My Blog Site</title>
<meta name="keywords" content="">
<meta name="description" content="day01 c&#43;&#43; 基础 对 C 拓展 头文件
using namespace std; 命名空间 cout &laquo; &ldquo;jj&rdquo;; (&laquo; 运算符重载)
register
bool
c 表达式返回的是一个值 c&#43;&#43;表达式返回的是一个变量(*(a&lt;b? &amp;a:&amp;b) = 30)
const: const int *a; int * const a; const int * const a;
但 c 中的 const 还可更加指针修改，并不是真正的常量，cpp 才是，把常量放入符号表里面，不会变，取地址的话会另外为 a 赋空间。
const 有作用域，#define 无
引用(Type&amp; name = var;) 由来：int a = 1; 就可以用 a 操作其地址，那可不可以给这个地址空间取另外的名字 b 吗？
和指针一样占 4 个字节，给内存取别名
应用：做函数形参，不用传地址！
引用做函数返回值，接的是什么就给什么，可以是值，可以是指针
引用做左值，函数返回值是一个引用，那么函数中要用 static 变量
指针引用： int * &amp;p1 = p;">
<meta name="author" content="liukanglai">
<link rel="canonical" href="http://localhost:1313/posts/computer/language/c-cpp/course%E6%89%AB%E5%9C%B0%E5%83%A7/cpp1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.dc96e9e0118e5e264a03d68b104df6ae869cfb73c61f5f89dd91aeb16b0d8c03.css" integrity="sha256-3Jbp4BGOXiZKA9aLEE32roac&#43;3PGH1&#43;J3ZGusWsNjAM=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/computer/language/c-cpp/course%E6%89%AB%E5%9C%B0%E5%83%A7/cpp1/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
  

<meta property="og:title" content="" />
<meta property="og:description" content="day01 c&#43;&#43; 基础 对 C 拓展 头文件
using namespace std; 命名空间 cout &laquo; &ldquo;jj&rdquo;; (&laquo; 运算符重载)
register
bool
c 表达式返回的是一个值 c&#43;&#43;表达式返回的是一个变量(*(a&lt;b? &amp;a:&amp;b) = 30)
const: const int *a; int * const a; const int * const a;
但 c 中的 const 还可更加指针修改，并不是真正的常量，cpp 才是，把常量放入符号表里面，不会变，取地址的话会另外为 a 赋空间。
const 有作用域，#define 无
引用(Type&amp; name = var;) 由来：int a = 1; 就可以用 a 操作其地址，那可不可以给这个地址空间取另外的名字 b 吗？
和指针一样占 4 个字节，给内存取别名
应用：做函数形参，不用传地址！
引用做函数返回值，接的是什么就给什么，可以是值，可以是指针
引用做左值，函数返回值是一个引用，那么函数中要用 static 变量
指针引用： int * &amp;p1 = p;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/computer/language/c-cpp/course%E6%89%AB%E5%9C%B0%E5%83%A7/cpp1/" /><meta property="og:image" content="http://localhost:1313/papermod-cover.png"/><meta property="article:section" content="posts" />



<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://localhost:1313/papermod-cover.png"/>

<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="day01 c&#43;&#43; 基础 对 C 拓展 头文件
using namespace std; 命名空间 cout &laquo; &ldquo;jj&rdquo;; (&laquo; 运算符重载)
register
bool
c 表达式返回的是一个值 c&#43;&#43;表达式返回的是一个变量(*(a&lt;b? &amp;a:&amp;b) = 30)
const: const int *a; int * const a; const int * const a;
但 c 中的 const 还可更加指针修改，并不是真正的常量，cpp 才是，把常量放入符号表里面，不会变，取地址的话会另外为 a 赋空间。
const 有作用域，#define 无
引用(Type&amp; name = var;) 由来：int a = 1; 就可以用 a 操作其地址，那可不可以给这个地址空间取另外的名字 b 吗？
和指针一样占 4 个字节，给内存取别名
应用：做函数形参，不用传地址！
引用做函数返回值，接的是什么就给什么，可以是值，可以是指针
引用做左值，函数返回值是一个引用，那么函数中要用 static 变量
指针引用： int * &amp;p1 = p;"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "http://localhost:1313/posts/computer/language/c-cpp/course%E6%89%AB%E5%9C%B0%E5%83%A7/cpp1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "day01 c++ 基础 对 C 拓展 头文件\nusing namespace std; 命名空间 cout \u0026laquo; \u0026ldquo;jj\u0026rdquo;; (\u0026laquo; 运算符重载)\nregister\nbool\nc 表达式返回的是一个值 c++表达式返回的是一个变量(*(a\u0026lt;b? \u0026amp;a:\u0026amp;b) = 30)\nconst: const int *a; int * const a; const int * const a;\n但 c 中的 const 还可更加指针修改，并不是真正的常量，cpp 才是，把常量放入符号表里面，不会变，取地址的话会另外为 a 赋空间。\nconst 有作用域，#define 无\n引用(Type\u0026amp; name = var;) 由来：int a = 1; 就可以用 a 操作其地址，那可不可以给这个地址空间取另外的名字 b 吗？\n和指针一样占 4 个字节，给内存取别名\n应用：做函数形参，不用传地址！\n引用做函数返回值，接的是什么就给什么，可以是值，可以是指针\n引用做左值，函数返回值是一个引用，那么函数中要用 static 变量\n指针引用： int * \u0026amp;p1 = p;",
  "keywords": [
    
  ],
  "articleBody": "day01 c++ 基础 对 C 拓展 头文件\nusing namespace std; 命名空间 cout « “jj”; (« 运算符重载)\nregister\nbool\nc 表达式返回的是一个值 c++表达式返回的是一个变量(*(a\nconst: const int *a; int * const a; const int * const a;\n但 c 中的 const 还可更加指针修改，并不是真正的常量，cpp 才是，把常量放入符号表里面，不会变，取地址的话会另外为 a 赋空间。\nconst 有作用域，#define 无\n引用(Type\u0026 name = var;) 由来：int a = 1; 就可以用 a 操作其地址，那可不可以给这个地址空间取另外的名字 b 吗？\n和指针一样占 4 个字节，给内存取别名\n应用：做函数形参，不用传地址！\n引用做函数返回值，接的是什么就给什么，可以是值，可以是指针\n引用做左值，函数返回值是一个引用，那么函数中要用 static 变量\n指针引用： int * \u0026p1 = p;\n常引用：int x = 30; const int \u0026y = x; y 是 x 的只读属性，不能通过 y 修改 x; (const int \u0026y = 30;)\n作用：传参，不用形参分配内存，且起只读作用\ninline 内联函数，替代 c 语言中：#define FUN(a,b)((a) \u003c (b) ? (a) : (b))\n直接在主函数中放入 inline 函数片段运行\n和 #define 宏的区别：宏只是机械的进行变量替换，而内联函数同普通函数\n函数的默认参数\n函数的占位参数\n占位参数也可加默认值\nnew/delete\n面向对象 面向对象是类的运行，面向过程：函数的运行\n对象的生命周期，类之间的关系？\n成员变量，成员函数，运行顺序？\n重载：\n函数的名一样，但参数的个数或类型或顺序不一样。注：只是放回值不一样不是重载\n函数指针！typedef void (*fun)(int a);\n类和对象 构造函数：类名\n只要自己定义了构造函数，就没有默认的了\n调用方法：Class A(1); Class A; VS Class A(); Class A = 1; Class A = (1, 2);\n析构函数： ~类名\nClass A = Class(1,2);(匿名对象) Class A = B; VS A=B;\n当函数返回一个对象时，会调用 copy 构造函数创建一个匿名对象，如果使用函数的返回值初始化一个对象，则将此匿名对象转正，若无，则无用析构掉\n默认的 copy 构造函数是浅 copy，类里面的指针变量只是简单复制一下。要使用，自己写深 copy 构造函数\n构造函数的初始化列表：需要初始化的变量！A(int a): b(1), c(2); 那构造函数的运行顺序（先 b 后 a），析构函数的运行顺序相反。\n静态成员：static 属于这个类的所有对象，静态成员函数只能访问静态成员变量，普通变量它不知道是谁的\n函数后面加一个 const，表示修饰的是 This 指针！\n封装 属性和方法的封装和权限\npublic private protected，默认是私有的\nc++如何构建面向对象模型：\n如何管理类中的代码：成员变量和成员函数分开存储，变量在对象中，static 在全局区，成员对象和函数都包含一个指向对象的指针（在代码区），static 无，任是内存四区模型！ 对象之间的关系 友元 访问类的 private friend 运算符重载 自定义数据类型的运算符操作，ps：复数相加 operator+ 函数调用 是全局函数，成员函数（权限问题需要友元函数） 前置++和后置++只有返回值不同，如何区分？占位符！ \u003e\u003e 的重载只能用全局函数，返回值用 osream\u0026 继承 访问控制：父类的 public private protected 权限继承用 public private protected 权限变化，(三看原则) 赋值兼容性原则：基类指针可以指向子类对象（用子类对象的地址给父类赋值）； 继承中的构造和析构顺序 child.father:: b = 10; 多重继承二义性： virtual 虚继承 有些二义性无法解决 多态 父类用子类的函数！框架已搭好\n一套函数可以反复用，只要传进来的子类不同！是面向对象 3 大概念的核心\n加 virtual ！子类可不加，实现多态\n虚析构函数：通过父类指针，调用子类对象的析构函数，释放所有资源（直接通过子类对象删时也可）\n重载（同一个类中）和重写（父类和子类函数一模一样，加 virtual 是多态，不加是重定义）；子类无法重载父类的函数，同名会覆盖！\n三个条件：继承，virtual 重写，父类指针（引用）指向子类对象\n实现多态的原理：vptr 指针，虚函数表\nvptr 指针的分步初始化：先完成父类的构造函数，vptr 指向父类的虚函数表，然后指向子类的\n纯虚函数和抽象类 virtual int get() = 0;\n多接口继承没有普通的多继承的二义性问题\n面向抽象类编程（接口）\n重要的思想：继承和组合，注入，控制反转 IOC，MVC(model, view, control)，面向对象思想拓展 aop 思想(横向编程)\nC 面向接口编程和 C 多态 函数指针 int (*fun)(int a, int b) 进阶用法，函数指针做函数参数 (虚函数表，多态) 回调函数: 定义一个函数指针类型（typedef）约定任务函数的规范，以后编写者写好，使用者调用即可 p280 观看\n异常 try catch 栈解旋：throw 后，类析构 throw 的变量的生命周期是啥，如果使用一个元素来接异常，会 copy 构造函数；如果是引用，会使用那个 throw 时的对象 Exception 类型转换\nstatic_cast: 静态类型转换，int-\u003echar… 编译时做类型检查，对于 c 中的隐式类型转换 reinterpret_cast: 重新解释转换，不同类型的强制类型转换 dynamic_cast: 动态类型转换，子类和父类之间的多态类型转换 const_cast: 把只读变为可改 Type B = static_cast(A); OI iostream\ncout/cin\ncin.get()\ncin.getline(buf, 256)\ncin.ingore()\ncin.peek()\ncin.putback()\ncout\n文件\n提高 函数模版和类模版 就是泛型编程\n函数的参数类型不一样，但实现的功能一样，如何只定义一个函数处理 重载：普通函数可以隐式转换数据类型，函数模板不会，严格验证类型；都匹配时，优先使用普通函数(加\u003c\u003e使用模板)；模板更好匹配，则调用函数模板 c++ 编译器会根据函数的调用来生成不同的函数，有几个不同的形参生成几个；两次编译，声明，调用 // 开始泛型编程 template\u003ctypename T, typename T1\u003e void swap(T \u0026a, T1 \u0026b){ T c; c = a; a = b; b = c; } swap\u003cint,int\u003e(x,y); 类模板 类中的数据不受具体数据类型的影响 Linux 内核链表 子类派生时，需要具体指定父类的模板类型，才能分配大小；也可以从模板类派生模板类。 类模板的 static，几个类型有几个 static stl 容器 vector\nstring\nstack\nqueue\n算法 迭代器 设计模式 boost ",
  "wordCount" : "362",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "liukanglai"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/computer/language/c-cpp/course%E6%89%AB%E5%9C%B0%E5%83%A7/cpp1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My Blog Site",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="My Blog Site (Alt + H)">My Blog Site</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/liukanglai" title="Github">
                    <span>Github</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title">
      
    </h1>
    <div class="post-meta">2 min&amp;nbsp;·&amp;nbsp;liukanglai&nbsp;|&nbsp;<a href="https://github.com/liukanglai/liukanglai.github.io/content/posts/Computer/Language/C-Cpp/course%e6%89%ab%e5%9c%b0%e5%83%a7/cpp1.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#day01" aria-label="day01">day01</a><ul>
                        
                <li>
                    <a href="#c-%e5%9f%ba%e7%a1%80" aria-label="c&#43;&#43; 基础">c++ 基础</a><ul>
                        
                <li>
                    <a href="#%e5%af%b9-c-%e6%8b%93%e5%b1%95" aria-label="对 C 拓展">对 C 拓展</a></li>
                <li>
                    <a href="#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1" aria-label="面向对象">面向对象</a><ul>
                        
                <li>
                    <a href="#%e7%b1%bb%e5%92%8c%e5%af%b9%e8%b1%a1" aria-label="类和对象">类和对象</a></li>
                <li>
                    <a href="#%e5%b0%81%e8%a3%85" aria-label="封装">封装</a></li>
                <li>
                    <a href="#%e7%bb%a7%e6%89%bf" aria-label="继承">继承</a></li>
                <li>
                    <a href="#%e5%a4%9a%e6%80%81" aria-label="多态">多态</a></li>
                <li>
                    <a href="#%e7%ba%af%e8%99%9a%e5%87%bd%e6%95%b0%e5%92%8c%e6%8a%bd%e8%b1%a1%e7%b1%bb" aria-label="纯虚函数和抽象类">纯虚函数和抽象类</a></li>
                <li>
                    <a href="#c-%e9%9d%a2%e5%90%91%e6%8e%a5%e5%8f%a3%e7%bc%96%e7%a8%8b%e5%92%8c-c-%e5%a4%9a%e6%80%81" aria-label="C 面向接口编程和 C 多态">C 面向接口编程和 C 多态</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%8f%90%e9%ab%98" aria-label="提高">提高</a><ul>
                        
                <li>
                    <a href="#%e5%87%bd%e6%95%b0%e6%a8%a1%e7%89%88%e5%92%8c%e7%b1%bb%e6%a8%a1%e7%89%88" aria-label="函数模版和类模版">函数模版和类模版</a></li>
                <li>
                    <a href="#stl" aria-label="stl">stl</a><ul>
                        
                <li>
                    <a href="#%e5%ae%b9%e5%99%a8" aria-label="容器">容器</a></li>
                <li>
                    <a href="#%e7%ae%97%e6%b3%95" aria-label="算法">算法</a></li>
                <li>
                    <a href="#%e8%bf%ad%e4%bb%a3%e5%99%a8" aria-label="迭代器">迭代器</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f" aria-label="设计模式">设计模式</a></li>
                <li>
                    <a href="#boost" aria-label="boost">boost</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="day01">day01<a hidden class="anchor" aria-hidden="true" href="#day01">#</a></h1>
<h2 id="c-基础">c++ 基础<a hidden class="anchor" aria-hidden="true" href="#c-基础">#</a></h2>
<h3 id="对-c-拓展">对 C 拓展<a hidden class="anchor" aria-hidden="true" href="#对-c-拓展">#</a></h3>
<ul>
<li>
<p>头文件</p>
</li>
<li>
<p>using namespace std; 命名空间 cout &laquo; &ldquo;jj&rdquo;; (&laquo; 运算符重载)</p>
</li>
<li>
<p>register</p>
</li>
<li>
<p>bool</p>
</li>
<li>
<p>c 表达式返回的是一个值 c++表达式返回的是一个变量<code>(*(a&lt;b? &amp;a:&amp;b) = 30)</code></p>
</li>
<li>
<p>const: <code>const int *a; int * const a; const int * const a;</code></p>
</li>
<li>
<p>但 c 中的 const 还可更加指针修改，并不是真正的常量，cpp 才是，把常量放入符号表里面，不会变，取地址的话会另外为 a 赋空间。</p>
</li>
<li>
<p>const 有作用域，#define 无</p>
</li>
<li>
<p>引用(Type&amp; name = var;) 由来：int a = 1; 就可以用 a 操作其地址，那可不可以给这个地址空间取另外的名字 b 吗？</p>
</li>
<li>
<p>和指针一样占 4 个字节，给内存取别名</p>
</li>
<li>
<p>应用：做函数形参，不用传地址！</p>
</li>
<li>
<p>引用做函数返回值，接的是什么就给什么，可以是值，可以是指针</p>
</li>
<li>
<p>引用做左值，函数返回值是一个引用，那么函数中要用 static 变量</p>
</li>
<li>
<p>指针引用： int * &amp;p1 = p;</p>
</li>
<li>
<p>常引用：int x = 30; const int &amp;y = x; y 是 x 的只读属性，不能通过 y 修改 x; (const int &amp;y = 30;)</p>
</li>
<li>
<p>作用：传参，不用形参分配内存，且起只读作用</p>
</li>
<li>
<p>inline 内联函数，替代 c 语言中：#define FUN(a,b)((a) &lt; (b) ? (a) : (b))</p>
</li>
<li>
<p>直接在主函数中放入 inline 函数片段运行</p>
</li>
<li>
<p>和 #define 宏的区别：宏只是机械的进行变量替换，而内联函数同普通函数</p>
</li>
<li>
<p>函数的默认参数</p>
</li>
<li>
<p>函数的占位参数</p>
</li>
<li>
<p>占位参数也可加默认值</p>
</li>
<li>
<p>new/delete</p>
</li>
</ul>
<h3 id="面向对象">面向对象<a hidden class="anchor" aria-hidden="true" href="#面向对象">#</a></h3>
<ul>
<li>
<p>面向对象是类的运行，面向过程：函数的运行</p>
</li>
<li>
<p>对象的生命周期，类之间的关系？</p>
</li>
<li>
<p>成员变量，成员函数，运行顺序？</p>
</li>
<li>
<p>重载：</p>
</li>
<li>
<p>函数的名一样，但参数的个数或类型或顺序不一样。注：只是放回值不一样不是重载</p>
</li>
<li>
<p>函数指针！typedef void (*fun)(int a);</p>
</li>
</ul>
<h4 id="类和对象">类和对象<a hidden class="anchor" aria-hidden="true" href="#类和对象">#</a></h4>
<ul>
<li>
<p>构造函数：类名</p>
</li>
<li>
<p>只要自己定义了构造函数，就没有默认的了</p>
</li>
<li>
<p>调用方法：Class A(1); Class A; VS Class A(); Class A = 1; Class A = (1, 2);</p>
</li>
<li>
<p>析构函数： ~类名</p>
</li>
<li>
<p>Class A = Class(1,2);(匿名对象) Class A = B; VS A=B;</p>
</li>
<li>
<p>当函数返回一个对象时，会调用 copy 构造函数创建一个匿名对象，如果使用函数的返回值初始化一个对象，则将此匿名对象转正，若无，则无用析构掉</p>
</li>
<li>
<p>默认的 copy 构造函数是浅 copy，类里面的指针变量只是简单复制一下。要使用，自己写深 copy 构造函数</p>
</li>
<li>
<p>构造函数的初始化列表：需要初始化的变量！A(int a): b(1), c(2); 那构造函数的运行顺序（先 b 后 a），析构函数的运行顺序相反。</p>
</li>
<li>
<p>静态成员：static 属于这个类的所有对象，静态成员函数只能访问静态成员变量，普通变量它不知道是谁的</p>
</li>
<li>
<p>函数后面加一个 const，表示修饰的是 This 指针！</p>
</li>
</ul>
<h4 id="封装">封装<a hidden class="anchor" aria-hidden="true" href="#封装">#</a></h4>
<ul>
<li>
<p>属性和方法的封装和权限</p>
</li>
<li>
<p>public private protected，默认是私有的</p>
</li>
<li>
<p>c++如何构建面向对象模型：</p>
<ol>
<li>如何管理类中的代码：成员变量和成员函数分开存储，变量在对象中，static 在全局区，成员对象和函数都包含一个指向对象的指针（在代码区），static 无，任是内存四区模型！</li>
<li>对象之间的关系</li>
<li></li>
</ol>
</li>
</ul>
<ol>
<li>友元</li>
</ol>
<ul>
<li>访问类的 private</li>
<li>friend</li>
</ul>
<ol>
<li>运算符重载</li>
</ol>
<ul>
<li>自定义数据类型的运算符操作，ps：复数相加</li>
<li>operator+ 函数调用 是全局函数，成员函数（权限问题需要友元函数）</li>
<li>前置++和后置++只有返回值不同，如何区分？占位符！</li>
<li>&gt;&gt; 的重载只能用全局函数，返回值用 osream&amp;</li>
</ul>
<h4 id="继承">继承<a hidden class="anchor" aria-hidden="true" href="#继承">#</a></h4>
<ul>
<li>访问控制：父类的 public private protected 权限继承用 public private protected 权限变化，(三看原则)</li>
<li>赋值兼容性原则：基类指针可以指向子类对象（用子类对象的地址给父类赋值）；</li>
<li>继承中的构造和析构顺序</li>
<li>child.father:: b = 10;</li>
<li>多重继承二义性：</li>
<li>virtual 虚继承</li>
<li>有些二义性无法解决</li>
</ul>
<h4 id="多态">多态<a hidden class="anchor" aria-hidden="true" href="#多态">#</a></h4>
<ul>
<li>
<p>父类用子类的函数！框架已搭好</p>
</li>
<li>
<p>一套函数可以反复用，只要传进来的子类不同！是面向对象 3 大概念的核心</p>
</li>
<li>
<p>加 virtual ！子类可不加，实现多态</p>
</li>
<li>
<p>虚析构函数：通过父类指针，调用子类对象的析构函数，释放所有资源（直接通过子类对象删时也可）</p>
</li>
<li>
<p>重载（同一个类中）和重写（父类和子类函数一模一样，加 virtual 是多态，不加是重定义）；子类无法重载父类的函数，同名会覆盖！</p>
</li>
<li>
<p>三个条件：继承，virtual 重写，父类指针（引用）指向子类对象</p>
</li>
<li>
<p>实现多态的原理：vptr 指针，虚函数表</p>
</li>
<li>
<p>vptr 指针的分步初始化：先完成父类的构造函数，vptr 指向父类的虚函数表，然后指向子类的</p>
</li>
</ul>
<h4 id="纯虚函数和抽象类">纯虚函数和抽象类<a hidden class="anchor" aria-hidden="true" href="#纯虚函数和抽象类">#</a></h4>
<ul>
<li>
<p>virtual int get() = 0;</p>
</li>
<li>
<p>多接口继承没有普通的多继承的二义性问题</p>
</li>
<li>
<p>面向抽象类编程（接口）</p>
</li>
</ul>
<blockquote>
<p>重要的思想：继承和组合，注入，控制反转 IOC，MVC(model, view, control)，面向对象思想拓展 aop 思想(横向编程)</p>
</blockquote>
<h4 id="c-面向接口编程和-c-多态">C 面向接口编程和 C 多态<a hidden class="anchor" aria-hidden="true" href="#c-面向接口编程和-c-多态">#</a></h4>
<ul>
<li>函数指针 <code>int (*fun)(int a, int b)</code></li>
<li>进阶用法，函数指针做函数参数 (虚函数表，多态)</li>
<li>回调函数: 定义一个函数指针类型（typedef）约定任务函数的规范，以后编写者写好，使用者调用即可</li>
</ul>
<blockquote>
<p>p280 观看</p>
</blockquote>
<ol>
<li>异常</li>
</ol>
<ul>
<li>try catch</li>
<li>栈解旋：throw 后，类析构</li>
<li>throw 的变量的生命周期是啥，如果使用一个元素来接异常，会 copy 构造函数；如果是引用，会使用那个 throw 时的对象</li>
<li>Exception</li>
</ul>
<blockquote>
<p>类型转换</p>
</blockquote>
<ul>
<li>static_cast: 静态类型转换，int-&gt;char&hellip; 编译时做类型检查，对于 c 中的隐式类型转换</li>
<li>reinterpret_cast: 重新解释转换，不同类型的强制类型转换</li>
<li>dynamic_cast: 动态类型转换，子类和父类之间的多态类型转换</li>
<li>const_cast: 把只读变为可改</li>
<li>Type B = static_cast&lt;Type&gt;(A);</li>
</ul>
<ol>
<li>OI</li>
</ol>
<ul>
<li>
<p>iostream</p>
</li>
<li>
<p>cout/cin</p>
</li>
<li>
<p>cin.get()</p>
</li>
<li>
<p>cin.getline(buf, 256)</p>
</li>
<li>
<p>cin.ingore()</p>
</li>
<li>
<p>cin.peek()</p>
</li>
<li>
<p>cin.putback()</p>
</li>
<li>
<p>cout</p>
</li>
<li>
<p>文件</p>
</li>
</ul>
<h2 id="提高">提高<a hidden class="anchor" aria-hidden="true" href="#提高">#</a></h2>
<h3 id="函数模版和类模版">函数模版和类模版<a hidden class="anchor" aria-hidden="true" href="#函数模版和类模版">#</a></h3>
<blockquote>
<p>就是泛型编程</p>
</blockquote>
<ul>
<li>函数的参数类型不一样，但实现的功能一样，如何只定义一个函数处理</li>
<li>重载：普通函数可以隐式转换数据类型，函数模板不会，严格验证类型；都匹配时，优先使用普通函数(加&lt;&gt;使用模板)；模板更好匹配，则调用函数模板</li>
<li>c++ 编译器会根据函数的调用来生成不同的函数，有几个不同的形参生成几个；两次编译，声明，调用</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 开始泛型编程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">T1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">swap</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span>
</span></span></code></pre></div><ul>
<li>类模板</li>
<li>类中的数据不受具体数据类型的影响</li>
<li>Linux 内核链表</li>
<li>子类派生时，需要具体指定父类的模板类型，才能分配大小；也可以从模板类派生模板类。</li>
<li>类模板的 static，几个类型有几个 static</li>
</ul>
<h3 id="stl">stl<a hidden class="anchor" aria-hidden="true" href="#stl">#</a></h3>
<h4 id="容器">容器<a hidden class="anchor" aria-hidden="true" href="#容器">#</a></h4>
<ol>
<li>
<p>vector</p>
<ul>
<li></li>
</ul>
</li>
<li>
<p>string</p>
</li>
<li>
<p>stack</p>
</li>
<li>
<p>queue</p>
</li>
</ol>
<h4 id="算法">算法<a hidden class="anchor" aria-hidden="true" href="#算法">#</a></h4>
<h4 id="迭代器">迭代器<a hidden class="anchor" aria-hidden="true" href="#迭代器">#</a></h4>
<h3 id="设计模式">设计模式<a hidden class="anchor" aria-hidden="true" href="#设计模式">#</a></h3>
<h3 id="boost">boost<a hidden class="anchor" aria-hidden="true" href="#boost">#</a></h3>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/computer/language/c-cpp/course%E6%89%AB%E5%9C%B0%E5%83%A7/cpp0/">
    <span class="title">« Prev</span>
    <br>
    <span></span>
  </a>
  <a class="next" href="http://localhost:1313/posts/computer/language/c-cpp/cworksummer/work/1-linked-list/1001/">
    <span class="title">Next »</span>
    <br>
    <span></span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://localhost:1313/">My Blog Site</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
